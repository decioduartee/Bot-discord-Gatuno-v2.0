{"version":3,"sources":["../src/util/request.ts"],"names":[],"mappings":"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","file":"request.js","sourcesContent":["import { request as https } from 'https'\nimport { IncomingMessage, RequestOptions, OutgoingMessage } from 'http'\nimport { parse as parseUrl } from 'url'\n\n/**\n * @ignore\n */\n/* istanbul ignore next */\nexport class Request {\n  public baseUrl: string\n\n  constructor (baseUrl: string) {\n    this.baseUrl = baseUrl\n  }\n\n  public api (subUrl: string, params: Object, token: string, type: 'key' | 'oauth'): Promise<any> {\n    const url = this.baseUrl + (subUrl.startsWith('/') ? '' : '/') + subUrl + this.parseParams(params) +\n                (type === 'key' ? (params ? `&key=${token}` : `?key=${token}`) : '')\n    return this.get(url, type === 'oauth' ? token : undefined)\n  }\n\n  public post (subUrl: string, params: Object, token: string, data: any): Promise<any> {\n    const url = this.baseUrl + (subUrl.startsWith('/') ? '' : '/') + subUrl + this.parseParams(params)\n    return this._post(url, data, token)\n  }\n\n  public put (subUrl: string, params: Object, token: string, data: any): Promise<any> {\n    const url = this.baseUrl + (subUrl.startsWith('/') ? '' : '/') + subUrl + this.parseParams(params)\n    return this._put(url, data, token)\n  }\n\n  private get (url: string, token?: string): Promise<any> {\n    const options = this.parseUrlToOptions(url, 'GET')\n\n    if (token) {\n      options.headers['Authorization'] = `Bearer ${token}`\n    }\n\n    return this.req(options, req => this.reqCallback(req))\n  }\n\n  private _post (url: string, data: any, token: string): Promise<any> {\n    const options = this.parseUrlToOptions(url, 'POST')\n\n    if (token) {\n      options.headers['Authorization'] = `Bearer ${token}`\n    }\n\n    return this.req(options, req => this.reqCallback(req, data))\n  }\n\n  private _put (url: string, data: any, token: string): Promise<any> {\n    const options = this.parseUrlToOptions(url, 'PUT')\n\n    if (token) {\n      options.headers['Authorization'] = `Bearer ${token}`\n    }\n\n    return this.req(options, req => this.reqCallback(req, data))\n  }\n\n  private parseUrlToOptions (url: string, type: 'POST' | 'PUT' | 'GET'): RequestOptions {\n    const parsed = parseUrl(url)\n\n    return {\n      hostname: parsed.hostname,\n      port: parsed.port ? parsed.port : 443,\n      path: parsed.path,\n      method: type,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }\n  }\n\n  private req (options: RequestOptions, reqFunction: (req: OutgoingMessage) => void) {\n    return new Promise((resolve, reject) => {\n      const cb = (res: IncomingMessage) => {\n        let data = ''\n\n        res.setEncoding('utf8')\n\n        res.on('data', chunk => {\n          data += chunk\n        })\n\n        res.on('end', () => {\n          if (res.statusCode === 404) {\n            return reject(new Error('Not found'))\n          }\n\n          const parsed = JSON.parse(data)\n\n          if (parsed.error) {\n            return reject(new Error(parsed.error.message))\n          }\n\n          return resolve(parsed)\n        })\n\n        res.on('error', error => {\n          return reject(error)\n        })\n      }\n\n      reqFunction(https(options, cb))\n    })\n  }\n\n  private reqCallback (req: OutgoingMessage, data?: any) {\n    req.on('error', error => {\n      throw error\n    })\n\n    if (data) {\n      req.write(data)\n    }\n\n    req.end()\n  }\n\n  private parseParams (params: Object) {\n    let url = ''\n\n    for (let param in params) {\n      url += (!url.includes('?') ? '?' : '&') + param + '=' + params[param]\n    }\n\n    return url\n  }\n}\n"],"sourceRoot":"../../src"}