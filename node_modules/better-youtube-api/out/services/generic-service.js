"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const util_1 = require("../util");
/**
 * @ignore
 */
class GenericService {
    /* istanbul ignore next */
    static getItemById(youtube, type, id) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!([__1.Video, __1.Channel, __1.Playlist, __1.YTComment].includes(type))) {
                return Promise.reject('Type must be a video, channel, playlist, or comment.');
            }
            const cached = util_1.Cache.get(`get://${type.endpoint}/${id}`);
            if (youtube._shouldCache && cached) {
                return cached;
            }
            const result = yield youtube._request.api(type.endpoint, {
                id,
                fields: encodeURIComponent(type.fields),
                part: type === __1.YTComment ? !type.part.includes('snippet') ? type.part + ',snippet' : type.part : type.part
            }, youtube.token, youtube._tokenType);
            if (result.items.length === 0) {
                return Promise.reject('Item not found');
            }
            let endResult;
            if (type === __1.YTComment) {
                endResult = new type(youtube, result.items[0], result.items[0].snippet.channelId ? 'channel' : 'video');
            }
            else {
                endResult = new type(youtube, result.items[0]);
            }
            youtube._cache(`get://${type.endpoint}/${id}`, endResult);
            return endResult;
        });
    }
    /* istanbul ignore next */
    static getPaginatedItems(youtube, endpoint, id, maxResults = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            const cached = util_1.Cache.get(`get://${endpoint}/${id}/${maxResults}`);
            if (youtube._shouldCache && cached) {
                return cached;
            }
            let items = [];
            const full = maxResults <= 0;
            const options = {
                part: 'snippet',
                maxResults: 0
            };
            let max;
            let clazz;
            let commentType;
            if (endpoint === 'playlistItems') {
                max = 50;
                clazz = __1.Video;
                options.playlistId = id;
            }
            else if (endpoint.startsWith('commentThreads')) {
                max = 100;
                clazz = __1.YTComment;
                const [, type] = endpoint.split(':');
                commentType = type ? type : 'video';
                endpoint = 'commentThreads';
                options[`${type}Id`] = id;
                options.part += ',replies';
                options.textFormat = 'plainText';
            }
            else if (endpoint === 'comments') {
                max = 100;
                clazz = __1.YTComment;
                options.parentId = id;
            }
            else if (endpoint === 'playlists:channel') {
                max = 50;
                clazz = __1.Playlist;
                endpoint = 'playlists';
                options.part += ',contentDetails,player';
                options.channelId = id;
            }
            else {
                return Promise.reject('Unknown item type ' + endpoint);
            }
            if (maxResults > max) {
                return Promise.reject(`Max results must be ${max} or below for ${endpoint}`);
            }
            options.maxResults = full ? max : maxResults;
            let results;
            let pages = null;
            let shouldReturn = !full;
            for (let i = 1; i < pages ? pages : 3; i++) {
                results = yield youtube._request.api(endpoint, options, youtube.token, youtube._tokenType).catch(() => {
                    return Promise.reject('Items not found');
                });
                if (results.items.length === 0) {
                    return Promise.reject('Items not found');
                }
                if (!pages) {
                    pages = results.pageInfo.totalResults / results.pageInfo.resultsPerPage;
                    if (pages <= 1) {
                        shouldReturn = true;
                    }
                    pages = Math.floor(pages);
                }
                results.items.forEach(item => {
                    let comment;
                    if (item.snippet.topLevelComment) {
                        comment = new __1.YTComment(youtube, item.snippet.topLevelComment, commentType);
                        items.push(comment);
                    }
                    else {
                        items.push(new clazz(youtube, item, commentType));
                    }
                    if (item.replies) {
                        item.replies.comments.forEach(reply => {
                            const created = new __1.YTComment(youtube, reply, commentType);
                            comment.replies.push(created);
                        });
                    }
                });
                if (results.nextPageToken && !shouldReturn) {
                    options.pageToken = results.nextPageToken;
                }
                else {
                    return items;
                }
            }
            youtube._cache(`get://${endpoint}/${id}/${maxResults}`, items);
            return items;
        });
    }
    /* istanbul ignore next */
    static getId(youtube, input, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let id = null;
            const cached = util_1.Cache.get(`get_id://${type.endpoint}/${input}`);
            if (cached) {
                return cached;
            }
            const cachedEntity = util_1.Cache.get(`get://${type.endpoint}/${input}`);
            if (cachedEntity && cachedEntity.id) {
                return cachedEntity.id;
            }
            if (input.includes('youtube.com') || input.includes('youtu.be')) {
                const idFromUrl = util_1.Parser.parseUrl(input)[type.name.toLowerCase()];
                // Custom channel URLs don't work that well
                if (type === __1.Channel && idFromUrl && !idFromUrl.startsWith('UC')) {
                    id = yield youtube._request.api('search', { q: idFromUrl, type: type.endpoint, part: 'id' }, youtube.token, youtube._tokenType).then(r => r.items[0] ? r.items[0].id.channelId : undefined);
                }
                id = idFromUrl;
            }
            if (id !== null && id !== undefined && id !== '') {
                return id;
            }
            if (type === __1.Channel && (!input.startsWith('UC') || input.includes(' '))) {
                id = yield youtube._request.api('search', {
                    q: input,
                    type: type.endpoint,
                    part: 'id', maxResults: 1
                }, youtube.token, youtube._tokenType).then(r => r.items[0] ? r.items[0].id.channelId : undefined);
            }
            else if (type === __1.Playlist && input.includes(' ')) {
                id = yield youtube._request.api('search', {
                    q: input,
                    type: type.endpoint,
                    part: 'id',
                    maxResults: 1
                }, youtube.token, youtube._tokenType).then(r => r.items[0] ? r.items[0].id.playlistId : undefined);
            }
            else if (type === __1.Video && (input.length < 11 || input.includes(' '))) {
                id = yield youtube._request.api('search', {
                    q: input,
                    type: type.endpoint,
                    part: 'id',
                    maxResults: 1
                }, youtube.token, youtube._tokenType).then(r => r.items[0] ? r.items[0].id.videoId : undefined);
            }
            else {
                id = input;
            }
            if (id === null || id === undefined || id === '') {
                return Promise.reject('Item not found');
            }
            youtube._cache(`get_id://${type.endpoint}/${input}`, id);
            return id;
        });
    }
}
exports.GenericService = GenericService;

//# sourceMappingURL=generic-service.js.map
